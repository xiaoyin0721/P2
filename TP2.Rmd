---
title: "P2"
author: "Tobias Pedersen, Dat Luong, Adam Rumi, Kristoffer Lading, Xiaoyin Chang, Kasper Sommer"
date: "4/3/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(mosaic)
```


# Introduction
I denne del af projektet, skabes en PRNG, med det formål, at simulere  og generere noget data, som først uniformfordeles. Dernæst bliver dataet så udsat for en box muller transformation så det bliver normalfordelt, og bedre kan analyseres statistisk interferentielt og deskriptivt.


# PRNG og TRNG
Indenfor tilfældige tal, findes der to termer. PRNG og TRNG, som står for "Pseudo Random Number Generator" og "True Random Number Generator". For at kunne generere tilfædlige tal ud fra deterministiske computere, har man brug for at bearbejde et input ved hjælp af en algoritme, og derved få et tilfældigt tal (også kaldet output) ud.

Den største forskel der er på pseudorandom tal og true random tal, er at de pseudorandom tal er blevet genereret til at ligne true random tal. De er altså ikke tilfældige, og deres output afhænger af et seed. Dette gør altså at resultaterne fra en PRNG kan reproduceres, hvis man sætter seed'et til en bestemt værdi. Dette gør PRNG'er godt egnet til simulationer. Man kan dele sine resultater fra en simulation med andre, hvis de også har sat seed'et, og dette gør det utroligt nemt at undersøge forskellige videnskabenlige fund. Siden at alt PRNG'er gør er at køre tal igennem en matematisk algoritme, betyder det, at de meget hurtigt og effektivt kan spytte tusinde af pseudotilfældige tal ud. 

Det er også muligt at generere true random tal. For eksempel, kan der ud fra atmosfærisk støj genereres true random tal. I modsætning til PRNG'er kan TRNG'er ikke lige så effektivt spytte tilfældige tal ud. Dette betyder altså at PRNG'er er meget bedre egnet til simulationer end TRNG'er er. TRNG'er er derimod bedre til ting som skal være tilfældige, såsom lotteriet eller gambling. De er også uden tvivl mere sikre indenfor krytografi end PRNG'er er. 

I dette projekt vil en PRNG implementeres i R, hvornæst de uniform fordelte tal skal transformeres v.h.a. Boxmuller. Dernæst vil R's indbyggede PRNG benyttes til at undersøge adskillige statistiske spørgsmål.

# Linear congruential generator
Målet ved en linear congruential generator er at genere et tilfældigt tal mellem 0 og 1. Linear congruential generator er en PRNG, så tallene der fås fra generatoren, vil ikke være fuldstændigt tilfældige. 
Der er 4 vigtige værdier indenfor en linear congruential generator.:  
	X0, som svarer til denne generators seed; X0 $\leq$ 0.  
	a, som bliver ganget på X0; a $\leq$ 0.  
	c, som bliver adderet til X0; c $\leq$ 0.  
	m, kaldet modulus; m > X0, m > a, m > c.  
Disse værdier vil blive brugt i den nedenstående ligning.:  
      $X_{(n+1)}=(a*X_n+c)mod(m)$  
Her vil man starte med at indsætte X0 på Xn’s plads, og ud fra dette kan man finde X1. Derefter kan man indsætte X1 på Xn’s plads og derefter få X2. Denne proces kan gentages så mange gange som man har brug for.
Det er vigtigt at nævne, at før eller siden vil tallene fra sådanne en generator begynde at gentage sig selv. Ved at ændre m til et meget højt tal, vil der dog gå meget lang tid før at tallene begynder at gentage sig selv. Andre der bruger denne generator anbefaler 2^31. 
De tilfældige tal man kan få ud af denne generator, er uniform fordelt. Ved at omhyggeligt vælge sine a, c og m værdier kan man også sørge for at tallene man får, ikke ser ud til at have nogen korrelation med hinanden. Linear congruential generators er generelt også hurtige og kræver ikke særlig meget plads. En ulempe ved LCG er at dens state ikke er stor nok, se nedenstående billede.

![](C:/Users/tobop/OneDrive - Aalborg Universitet/Documents/GitHub/P2/PRNG_Forklaring.jpg){width=50%}

Når ens program startes op får man en state ud fra det seed man bruger. Denne state kan dernæst ændres til en anden state ved hjælp af en irreversibel funktion f. For at få et random tal ud, kan man bruge en irreversibel funktion g på staten. Dette kan dog kun gøres en gang per state, hvorimod andre PRNG’er kan have flere states på en gang. Et eksempel er Mersenne twister, men denne vil ikke gennemgåes i rapporten.

# Implementering af linear congruential generator
Nedenstående blok kode blev brugt til at lave den lineære kongruentiale generator (LCG)
```{r}
X_0 = 1576

linear_congruence <- function(i) {
t <- 0
a <- 11102357
c <- 21353
m <- 2**32
v1 <- c()
while(t < i){
  X_0 <- (a*X_0+c)%%m
  v1 <- c(v1 , as.integer(((X_0)/m)*100))
  t <- t + 1
}
return(v1)
}
```

Som beskrevet i afsnittet om LCG'er, skal generatoren bruge et seed. Derfor sættes $X_0$ lig med et tilfældigt tal, som i dette tilfælde er $1576$. Der skulle også bruges en $a$, $c$ og $m$ værdi, som i denne kode er sat til henholdsvis $11,102,357$, $21,353$ og $2^{32}$. Der er også oprettet to variabler: $t$ og $i$, som bruges i programmet, hvor $i$ er en parameter for funktionen, som svarer til det ønskede antal tilfældigt genererede tal, og $t$ har en startsværdi på 0, og øges med 1, hvert gang et tilfældigt tal genereres. Funktionen er sat op således, at så længe $t$ er mindre end $i$, vil $X_0$ blive brugt til at udregne en ny $X_0$ værdi. Værdien bliver dernæst tilføjet til en vektor $v1$, dog ikke før at værdien bliver divideret med $m$ og ganget med 100. Dernæst bliver $1$ adderet til $t$, og så loop'er funktionen. Resultatet af denne funktion, kan ses forneden:  


```{r Linear Congruence, echo=FALSE}

#linear_congruence(i=100000)
gf_histogram(~linear_congruence(i=100000), breaks = seq(0, 100, by=10), fill="black", col="grey", xlim = c(0, 100), ylab = "Antal", xlab = "Tilfældige tal inddelt i intervaller", title = "Resultaterne af den implementerede PRNG")
    
```

# Boxmuller
Box-Muller transformationen er en metode, hvori to uniforme random variabler transformeres til et par uafhængige standard normal random variabler. Den primære ide er at ændre koordinatorne fra kartetiske til polære koordinator.
Sammenhænget mellem kartetiske og polære-koordinator er:
$x = cos(\theta)*r$
$y = sin(\theta)*r$
Ifølge boxmuller erstattes $\theta$ med $2\pi*U_2$ og $r$ erstattes med $\sqrt V$
hvor V er $-2*ln*U_1$
Her skal der altså bruges to værdier, $U_1$ og $U_2$. Disse værdier er de uniform random tal.
Det man får ud af dette, er to tal x og y, som i dette tilfælde er uafhængige random variabler med en normalfordeling. Forneden kan resultaterne af Box-Muller transformationen ses:

```{r echo=FALSE}

Box_muller_transform <- function(){
  n <- 10^4
  samples <- matrix(ncol = 2, nrow = n)
  uni_rand_num1 <- runif(10^4, 0, 1)
  uni_rand_num2 <- runif(10^4, 0, 1)
  R <- sqrt(-2*log(uni_rand_num1))
  theta <- 2*pi*uni_rand_num2
  X <- R*cos(theta)
  Y <- R*sin(theta)
  samples[,1] <- X
  samples[,2] <- Y 
  
  label <- rep(c("x", "y"),n)
  value <- c(samples[,1],samples[,2])
  df <- data.frame(value, label)
  library(ggplot2)
  plt <- ggplot(df, aes(x=value, color=label, fill=label)) + geom_histogram(aes(y=..density..), bins = 60, position= "identity", alpha =0.3) + labs(x="Value", y="Density") + theme_bw()
  print(plt)
}

Box_muller_transform()


```



